### Course Learning Reflections

### 1. **Types of Problems in Nature**
   - **Iteration**: Repetitive tasks (e.g., daily routines).
   - **Recursion**: Self-similar patterns (e.g., fractals).
   - **Backtracking**: Trial and error (e.g., decision-making).

### 2. **Space and Time Efficiency**
   - **Time Efficiency**: Measures algorithm speed (e.g., O(n)).
   - **Space Efficiency**: Measures memory usage.
   - **Growth Orders**: Big-O notation (constant, logarithmic, etc.).

### 3. **Design Principles**
   - **Divide and Conquer**: Break problems into smaller ones (e.g., Merge Sort).
   - **Greedy Algorithms**: Opt for local optimization (e.g., Knapsack).
   - **Dynamic Programming**: Solve complex problems by breaking them into subproblems (e.g., Fibonacci).

### 4. **Hierarchical Data & Tree Structures**
   - Types: **BST**, **AVL**, **Red-Black**, **Heap**, **Trie**.
   - Optimize search and insertion based on problem type.

### 5. **Array Query Algorithms**
   - **Need**: Efficient querying in large datasets.
   - **Applications**: Range queries, sum queries in databases.

### 6. **Tree vs Graph and Traversals**
   - **Tree**: Hierarchical, no cycles.
   - **Graph**: More complex, may have cycles.
   - **Traversals**: DFS, BFS (Graph), In-order, Pre-order (Tree).

### 7. **Sorting and Searching Algorithms**
   - **Sorting**: **Quick Sort**, **Merge Sort**, etc. (Applications: databases).
   - **Searching**: **Binary Search** (Applications: large datasets).

### 8. **Graph Algorithms**
   - **Spanning Trees**: Algorithms like Kruskal’s (network design).
   - **Shortest Paths**: Dijkstra’s, Bellman-Ford (routing, navigation).

### 9. **Algorithm Design Techniques**
   - **Brute Force**, **Greedy**, **Divide and Conquer**, **Dynamic Programming**, **Backtracking**.

[BUSINESS CASES](https://github.com/01fe23bcs138/rsahana.github.io/wiki/Business-Cases)
