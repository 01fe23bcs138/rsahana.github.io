## Portfolio

### Hello, Sahana Rüëã

I am passionate about technology and problem-solving. Here's a glimpse of my work:

## üõ†Ô∏è Projects
- **Project 1**: Created 
- **Project 2**: Built a Gym machine via Arduino showcasing exercises like Pulley and Elliptical Trainer for advertisement purposes.

## üöÄ Skills
- C++, Python, C
- Data Structures and Algorithms

## üåê Find Me Online
- [GitHub](https://github.com/your-github-username)
- [LinkedIn](https://linkedin.com/in/your-linkedin-profile)

## Portfolio Topic

<dl>
<dt>Course Name : DESIGN Analysis and Algorithms</dt>
<dd>Algorithmic Problem Solving</dd>
<dt>Course Code</dt>
<dd>Course Code Placeholder</dd>
<dt>Name</dt>
<dd>Your Name</dd>
<dt>SRN</dt>
<dd>Your SRN</dd>
<dt>Course Instructor</dt>
<dd>Instructor Name Placeholder</dd>
<dt>University</dt>
<dd>Your University Name</dd>
<dt>Portfolio Topic/Domain</dt>
<dd>Google</dd>
</dl>

<br> 
> ‚ÄúThe only way to do great work is to love what you do.‚Äù ‚Äì Steve Jobs
>

### Course Learning Reflections

### 1. **Types of Problems in Nature**
   - **Iteration**: Repetitive tasks (e.g., daily routines).
   - **Recursion**: Self-similar patterns (e.g., fractals).
   - **Backtracking**: Trial and error (e.g., decision-making).

### 2. **Space and Time Efficiency**
   - **Time Efficiency**: Measures algorithm speed (e.g., O(n)).
   - **Space Efficiency**: Measures memory usage.
   - **Growth Orders**: Big-O notation (constant, logarithmic, etc.).

### 3. **Design Principles**
   - **Divide and Conquer**: Break problems into smaller ones (e.g., Merge Sort).
   - **Greedy Algorithms**: Opt for local optimization (e.g., Knapsack).
   - **Dynamic Programming**: Solve complex problems by breaking them into subproblems (e.g., Fibonacci).

### 4. **Hierarchical Data & Tree Structures**
   - Types: **BST**, **AVL**, **Red-Black**, **Heap**, **Trie**.
   - Optimize search and insertion based on problem type.

### 5. **Array Query Algorithms**
   - **Need**: Efficient querying in large datasets.
   - **Applications**: Range queries, sum queries in databases.

### 6. **Tree vs Graph and Traversals**
   - **Tree**: Hierarchical, no cycles.
   - **Graph**: More complex, may have cycles.
   - **Traversals**: DFS, BFS (Graph), In-order, Pre-order (Tree).

### 7. **Sorting and Searching Algorithms**
   - **Sorting**: **Quick Sort**, **Merge Sort**, etc. (Applications: databases).
   - **Searching**: **Binary Search** (Applications: large datasets).

### 8. **Graph Algorithms**
   - **Spanning Trees**: Algorithms like Kruskal‚Äôs (network design).
   - **Shortest Paths**: Dijkstra‚Äôs, Bellman-Ford (routing, navigation).

### 9. **Algorithm Design Techniques**
   - **Brute Force**, **Greedy**, **Divide and Conquer**, **Dynamic Programming**, **Backtracking**.


